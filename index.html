<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Confluence of Disciplines</title>
<style>
  @font-face {
    font-family: 'Neue Haas';
    src: url('fonts/NeueHaasDisplay-Light.woff2') format('woff2'),
         url('fonts/NeueHaasDisplay-Light.woff') format('woff'),
         url('fonts/NeueHaasDisplay-Light.ttf') format('truetype');
    font-weight: 300;
    font-style: normal;
  }
  @font-face {
    font-family: 'Neue Haas';
    src: url('fonts/NeueHaasDisplay-Roman.woff2') format('woff2'),
         url('fonts/NeueHaasDisplay-Roman.woff') format('woff'),
         url('fonts/NeueHaasDisplay-Roman.ttf') format('truetype');
    font-weight: 400;
    font-style: normal;
  }
  @font-face {
    font-family: 'Neue Haas';
    src: url('fonts/NeueHaasDisplay-Medium.woff2') format('woff2'),
         url('fonts/NeueHaasDisplay-Medium.woff') format('woff'),
         url('fonts/NeueHaasDisplay-Medium.ttf') format('truetype');
    font-weight: 500;
    font-style: normal;
  }
  @font-face {
    font-family: 'Neue Haas';
    src: url('fonts/NeueHaasDisplay-Bold.woff2') format('woff2'),
         url('fonts/NeueHaasDisplay-Bold.woff') format('woff'),
         url('fonts/NeueHaasDisplay-Bold.ttf') format('truetype');
    font-weight: 700;
    font-style: normal;
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { overflow: hidden; background: #000; font-family: 'Neue Haas', 'Helvetica Neue', Helvetica, Arial, sans-serif; }
  canvas { display: block; }

  #overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
    z-index: 10;
    padding: 40px;
  }

  #nav {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
  }

  #logo {
    font-weight: 700;
    font-size: 34px;
    line-height: 1.1;
    color: #fff;
    letter-spacing: -0.5px;
  }
  #logo .tm {
    font-size: 17px;
    vertical-align: super;
    font-weight: 400;
    line-height: 1;
  }

  #nav-links {
    display: flex;
    gap: 48px;
    pointer-events: auto;
  }
  #nav-links a {
    color: #fff;
    text-decoration: none;
    font-size: 20px;
    font-weight: 300;
    letter-spacing: 0.5px;
  }
  #nav-links a:hover {
    opacity: 0.7;
  }

  #content {
    position: absolute;
    left: 40px;
    bottom: 18vh;
    right: 40px;
  }

  #subtitle {
    font-size: 18px;
    font-weight: 300;
    color: rgba(255,255,255,0.85);
    line-height: 1.7;
    letter-spacing: 0.3px;
    font-family: monospace;
    margin-bottom: 40px;
  }

  #headline {
    font-size: clamp(64px, 8vw, 120px);
    font-weight: 500;
    color: #fff;
    line-height: 1.05;
    letter-spacing: -2px;
    margin-bottom: 48px;
  }

  #divider {
    width: 160px;
    height: 2px;
    background: #fff;
    margin-bottom: 28px;
  }

  #apply-link {
    font-size: 24px;
    font-weight: 400;
    color: #fff;
    letter-spacing: 0.5px;
    pointer-events: auto;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 10px;
  }
  #apply-link:hover {
    opacity: 0.7;
  }
  #apply-link .arrow {
    font-size: 28px;
    font-weight: 300;
  }
</style>
</head>
<body>
<div id="overlay">
  <div id="nav">
    <div id="logo">Thiel<br>Fellowship<span class="tm">&trade;</span></div>
    <div id="nav-links">
      <a href="/faq">FAQ</a>
      <a href="/apply">Apply</a>
    </div>
  </div>
  <div id="content">
    <div id="subtitle">The Thiel Fellowship gives $200,000 to young people who want<br>to build new things instead of sitting in a classroom.</div>
    <div id="headline">Two years. $200,000.<br>Some ideas can&rsquo;t wait.</div>
    <div id="divider"></div>
    <a id="apply-link" href="/apply">Apply Now <span class="arrow">&rarr;</span></a>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// ─── Scene setup ───────────────────────────────────────────
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
camera.position.set(0, 0, 18);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.rotateSpeed = 0.6;
controls.minDistance = 10;
controls.maxDistance = 80;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.35;

// ─── Discipline color palettes (evenly spaced around color wheel) ──
const disciplines = [
  { name: 'Art',        hueMin: 0.97, hueMax: 1.03 },  // red
  { name: 'Music',      hueMin: 0.06, hueMax: 0.12 },  // orange
  { name: 'Design',     hueMin: 0.12, hueMax: 0.18 },  // yellow
  { name: 'Biology',    hueMin: 0.25, hueMax: 0.35 },  // green
  { name: 'Technology', hueMin: 0.40, hueMax: 0.48 },  // teal
  { name: 'Science',    hueMin: 0.52, hueMax: 0.60 },  // cyan
  { name: 'Math',       hueMin: 0.62, hueMax: 0.70 },  // blue
  { name: 'Philosophy', hueMin: 0.78, hueMax: 0.86 },  // purple
];

// ─── Generate nodes (positions + hue only, color assigned after connections) ─
const NODE_COUNT = 280;
const SPHERE_RADIUS = 14;
const MAX_DIST = 5.2;
const nodes = [];

function randomInSphere(radius) {
  const u = Math.random();
  const r = radius * Math.pow(u, 0.5);
  const theta = Math.random() * Math.PI * 2;
  const phi = Math.acos(2 * Math.random() - 1);
  return new THREE.Vector3(
    r * Math.sin(phi) * Math.cos(theta),
    r * Math.sin(phi) * Math.sin(theta),
    r * Math.cos(phi)
  );
}

for (let i = 0; i < NODE_COUNT; i++) {
  const pos = randomInSphere(SPHERE_RADIUS);
  const dist = pos.length() / SPHERE_RADIUS;

  const numDisciplines = dist < 0.3 ? 2 : (dist < 0.55 && Math.random() > 0.4) ? 2 : 1;
  const shuffled = [...disciplines].sort(() => Math.random() - 0.5);
  const assignedDiscs = shuffled.slice(0, numDisciplines);

  let hue;
  if (assignedDiscs.length === 1) {
    const d = assignedDiscs[0];
    hue = d.hueMin + Math.random() * (d.hueMax - d.hueMin);
  } else {
    const d1 = assignedDiscs[0], d2 = assignedDiscs[1];
    const h1 = d1.hueMin + Math.random() * (d1.hueMax - d1.hueMin);
    const h2 = d2.hueMin + Math.random() * (d2.hueMax - d2.hueMin);
    hue = h1 + (h2 - h1) * (0.3 + Math.random() * 0.4);
  }
  hue = ((hue % 1) + 1) % 1;

  const baseSize = dist < 0.3  ? 0.5 + Math.random() * 0.9 :
                   dist < 0.55 ? 0.25 + Math.random() * 0.6 :
                   dist < 0.8  ? 0.12 + Math.random() * 0.35 :
                                 0.06 + Math.random() * 0.18;

  nodes.push({ pos, hue, size: baseSize, dist, color: null, connections: 0 });
}

// ─── Count connections ─────────────────────────────────────
for (let i = 0; i < nodes.length; i++) {
  for (let j = i + 1; j < nodes.length; j++) {
    if (nodes[i].pos.distanceTo(nodes[j].pos) < MAX_DIST) {
      nodes[i].connections++;
      nodes[j].connections++;
    }
  }
}
const maxConn = Math.max(...nodes.map(n => n.connections), 1);

// ─── Assign colors based on connection count ───────────────
// Most connected → full saturation, bright. Least → very desaturated, dimmer.
nodes.forEach(node => {
  const sat = 0.9 + Math.random() * 0.1;
  const lit = 0.38 + Math.random() * 0.12;
  node.color = new THREE.Color().setHSL(node.hue, sat, lit);
});

// ─── Generate textures pixel-by-pixel (no canvas gradient dithering) ──
function createRadialTexture(size, alphaFn) {
  const canvas = document.createElement('canvas');
  canvas.width = size;
  canvas.height = size;
  const ctx = canvas.getContext('2d');
  const imageData = ctx.createImageData(size, size);
  const data = imageData.data;
  const half = size / 2;

  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      const dx = (x - half + 0.5) / half;
      const dy = (y - half + 0.5) / half;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const alpha = alphaFn(Math.min(dist, 1));
      const idx = (y * size + x) * 4;
      data[idx]     = 255;
      data[idx + 1] = 255;
      data[idx + 2] = 255;
      data[idx + 3] = Math.round(alpha * 255);
    }
  }

  ctx.putImageData(imageData, 0, 0);
  const tex = new THREE.CanvasTexture(canvas);
  tex.minFilter = THREE.LinearMipmapLinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.generateMipmaps = true;
  return tex;
}

const circleTexture = createRadialTexture(512, d => {
  if (d < 0.55) return 1;
  if (d > 0.95) return 0;
  const t = (d - 0.55) / 0.4;
  return 1 - t * t * (3 - 2 * t);
});

const softTexture = createRadialTexture(512, d => {
  if (d >= 1) return 0;
  const inv = 1 - d;
  return 0.6 * inv * inv;
});

// ─── Node sprites ──────────────────────────────────────────
const spriteGroup = new THREE.Group();
scene.add(spriteGroup);

nodes.forEach(node => {
  const opacity = node.dist < 0.35 ? 0.3 + Math.random() * 0.15 :
                  node.dist < 0.6  ? 0.35 + Math.random() * 0.15 :
                                     0.4 + Math.random() * 0.15;
  const mat = new THREE.SpriteMaterial({
    map: circleTexture,
    color: node.color,
    transparent: true,
    opacity: opacity,
    blending: THREE.NormalBlending,
    depthWrite: false,
    depthTest: true,
  });
  const sprite = new THREE.Sprite(mat);
  sprite.position.copy(node.pos);
  sprite.scale.setScalar(node.size * 3.2);
  node.sprite = sprite;
  spriteGroup.add(sprite);

  const glowMat = new THREE.SpriteMaterial({
    map: softTexture,
    color: node.color,
    transparent: true,
    opacity: 0.25 + (1 - node.dist) * 0.15,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
  });
  const glow = new THREE.Sprite(glowMat);
  glow.position.copy(node.pos);
  glow.scale.setScalar(node.size * 5.5);
  node.glow = glow;
  spriteGroup.add(glow);
});

// ─── Connection lines (simple blended color) ───────────────
const linePositions = [];
const lineColors = [];

for (let i = 0; i < nodes.length; i++) {
  for (let j = i + 1; j < nodes.length; j++) {
    const d = nodes[i].pos.distanceTo(nodes[j].pos);
    if (d < MAX_DIST) {
      const alpha = 1 - d / MAX_DIST;
      const c = new THREE.Color().copy(nodes[i].color).lerp(nodes[j].color, 0.5);

      linePositions.push(
        nodes[i].pos.x, nodes[i].pos.y, nodes[i].pos.z,
        nodes[j].pos.x, nodes[j].pos.y, nodes[j].pos.z
      );

      const brightness = alpha * 0.52;
      lineColors.push(
        c.r * brightness, c.g * brightness, c.b * brightness,
        c.r * brightness, c.g * brightness, c.b * brightness
      );
    }
  }
}

const lineGeom = new THREE.BufferGeometry();
lineGeom.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
lineGeom.setAttribute('color', new THREE.Float32BufferAttribute(lineColors, 3));

const lineMat = new THREE.LineBasicMaterial({
  vertexColors: true,
  transparent: true,
  opacity: 0.7,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
});

const linesMesh = new THREE.LineSegments(lineGeom, lineMat);
linesMesh.renderOrder = -1;
scene.add(linesMesh);

// ─── Animation ─────────────────────────────────────────────
const originalScales = nodes.map(n => n.size * 3.2);
const originalGlowScales = nodes.map(n => n.size * 5.5);
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  nodes.forEach((node, i) => {
    const breathe = 1 + 0.08 * Math.sin(t * 0.7 + i * 0.4);
    node.sprite.scale.setScalar(originalScales[i] * breathe);
    node.glow.scale.setScalar(originalGlowScales[i] * breathe);

    const drift = 0.06;
    const dx = drift * Math.sin(t * 0.25 + i * 1.1);
    const dy = drift * Math.cos(t * 0.3 + i * 0.7);
    const dz = drift * Math.sin(t * 0.28 + i * 1.4);
    node.sprite.position.set(node.pos.x + dx, node.pos.y + dy, node.pos.z + dz);
    node.glow.position.set(node.pos.x + dx, node.pos.y + dy, node.pos.z + dz);
  });

  controls.update();
  renderer.render(scene, camera);
}

animate();

// ─── Resize ────────────────────────────────────────────────
window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
